
;; _    ____ ____ ____      /    _    ____ ____ _  _ ____ ____      /    ___  ____ ____ _  _ ____ _  _ ____ ____
;; |    |___ |__| |___     /     |    |___ |__| |  | |___ [__      /     |__] |__/ |__| |\ | |    |__| |___ [__
;; |___ |___ |  | |       /      |___ |___ |  |  \/  |___ ___]    /      |__] |  \ |  | | \| |___ |  | |___ ___]

{;; available-state-keys (see the bottom for example shapes for all these maps and vectors)
    ;;  :body - the view/query code itself
    ;;  :output - console output for card runners that support it (clojure repls, command-line, etc)
    ;;  :clover-kws - any clover / reactor params included (clover params will also be resolved if used in the leaf-fn is used)
    ;;  :data - any output value from the cards that support it (rowset data from sql, return value from repl, etc)
    ;;  :metadata - currently only for database calls
    ;;  :parent-metadata - (if exists) currently only for database calls
    ;;  :height-int - height of the container block in pixels
    ;;  :width-int - width of the container block in pixels
    ;;  :panel-key - block key, panel-key (same thing)
    ;;  :block-key - block key, panel-key (same thing)
    ;;  :data-key - view-key, query-key, data-key (same things)
    ;;  :view-key - view-key, query-key, data-key (same things)
    ;;  :query-key - view-key, query-key, data-key (same things)
    ;;  :tab-name - current tab the view is in (same as tab)
    ;;  :dragging? - is THIS item current being dragged?
    ;;  :dragging-body - the meta map payload of the dragged item
    ;;  :dragging-leaves - current state of the dragging items leaves
    ;;  :drag-from-self? - target and source are the same block
    ;;  :canvas-drop? - target is the canvas - no target block
    ;;  :type - :view or :field (for now)
    ;;  :tab - current tab the view is in (same as tab-name)
    ;;  :runner - runner responsible for executing the card (views, queries, clojure, shell, etc)
    ;;  :ui-keypath - location of the view in the format of [:block-id :runner :view-key]
    ;;               ^ note, the full keypath for the client would be [:panels :block-id :runner :view-key]
    ;;
    ;; If leaf type is :field, these map keys will *also* be available to pull in the function args
    ;;        - theses fields can also be used as raw keywords in the SQL where clause format
    ;;
    ;; [:field/data-type :field/cardinality :field/distinct-values :field/name :field/min
    ;;  :field/median :field/max :field/avg :field/top-values :field/is-group-by?]


 :views ;; run for every visible view on the client's screen (current tab) - RUN LEVEL
 {:is-query?     (fn [{:keys [runner]}]
                   (= runner :queries))
  :has-metadata? (fn [{:keys [metadata]}]
                   (not (empty? metadata)))
;;   :is-xtdb?      (fn [{:keys [metadata]}]
;;                    (and (not (empty? metadata))
;;                         (clojure.string/includes? (clojure.string/lower-case (str (get metadata :connection-id))) "xtdb")
;;                         (= (get metadata :database-type) "PostgreSQL")))
  :is-view?      (fn [{:keys [runner]}]
                   (= runner :views))
  :is-recharts?  (fn [{:keys [body runner]}]
                   (and (contains?
                         (set (flatten-to-keywords body)) ;; deep flattens the entire struc, leaving only a vector of keywords
                         :ResponsiveContainer)
                        (= runner :views)))
  :is-vega-lite?  (fn [{:keys [body runner]}]
                    (and (contains?
                          (set (flatten-to-keywords body)) ;; deep flattens the entire struc, leaving only a vector of keywords
                          :vega-lite)
                         (= runner :views)))
  :is-repl?      (fn [{:keys [runner]}]
                   (= runner :clojure))

  :sql-agg-types* (fn [_] [:sum :avg :min :max :count]) ;; leaf "batch" used a dynamic args for rules and action fns

  :repl-add-types* (fn [{:keys [drag-field drag-meta parent-metadata]}] ;; data-ref.data-trigger.render-trigger
                     (let [ttype (get drag-meta :type)
                           dtype (get drag-meta :data-type)
                           ;_ (pp [:drag-meta drag-meta])
                           ]
                       (cond (and (contains? #{"float" "string"} dtype) (= ttype :field)) [:data-ref :data-ref+sum]
                             ;(or (= ttype ":param") (= ttype ":where")) [:data-ref]
                             (= ttype :query) [:data-ref :data-trigger]
                             (= ttype :view)  [:render-trigger :data-ref]
                             (= ttype :data)  [:render-trigger :data-ref :data-trigger] ;; repls and runners
                             :else [:data-ref])))

  :pivotable-dims* (fn [{:keys [drag-field drag-meta parent-metadata]}]
                     (vec
                      (for [[k v] (get parent-metadata :fields)
                            :when (and
                                   (= (get v :data-type) "string")
                                   (< (get v :distinct 999) 20))] k)))

  :is-canvas-call? (fn [{:keys [data-key]}]
                     (= data-key :canvas))

  ;;:is-open-table-pull? [:= :dragging/type ":meta-tables"]

  :none/none [:= 45 45] ;; true ;; important UI stub - acts a signal that the block has received leaf answers (as opposed to nil/waiting)

  :is-self?     [:and :drag-from-self?]
  :is-recharts-and-view? [:and :is-recharts? :is-view?]

  :drag-from-same-connection? [:= :connection-id :drag-field/connection-id]

;;   :target-has-field?       (fn [{:keys [drag-field drag-meta metadata]}]
;;                              (not (empty? (get-in metadata [:fields (get drag-field :name)]))))
  :target-has-field?     (fn [{:keys [drag-field drag-meta metadata]}]
                           (or
                            (not (empty? (get-in metadata [:fields (get drag-meta :param-field)])))
                            (not (empty? (get-in metadata [:fields (get drag-field :name)])))))

  :target-is-group-by?  (fn [{:keys [body]}] ;; already has group-by or is all agg
                          (try
                            (or
                            ;; Has explicit group-by clause
                             (true? (not (empty? (get body :group-by))))
                            ;; Or all selects are aggregations
                             (let [select-items (get body :select [])
                                   agg-fns #{:count :sum :avg :min :max :distinct}]
                               (and
                                (not (empty? select-items))
                                (every? vector? select-items))))
                            (catch Exception _ false)))

  :parent-has-field?     (fn [{:keys [drag-field drag-meta parent-metadata]}]
                           (or
                            (not (empty? (get-in parent-metadata [:fields (get drag-meta :param-field)])))
                            (not (empty? (get-in parent-metadata [:fields (get drag-field :name)])))))

  :grandparent-has-field?     (fn [{:keys [drag-field drag-meta grandparent-metadata]}]
                                (or
                                 (not (empty? (get-in grandparent-metadata [:fields (get drag-meta :param-field)])))
                                 (not (empty? (get-in grandparent-metadata [:fields (get drag-field :name)])))))

;;   :parent-has-param-field? (fn [{:keys [drag-field parent-metadata]}]
;;                              (not (empty? (get-in parent-metadata [:fields (get drag-field :name)]))))
;;   :parent-has-param-field? (fn [{:keys [drag-meta parent-metadata]}]
;;                              (not (empty? (get-in parent-metadata [:fields (get drag-meta :target)]))))

  :drag-has-same-parent? (fn [{:keys [dragging-body metadata body]}]
                           (let [src-drag-table (get-in dragging-body [:drag-meta :source-query])
                                 target-from (first (flatten (get body :from)))]
                             ;;(println src-drag-table target-from)
                             (or (= target-from src-drag-table)
                                 (= src-drag-table
                                    (keyword (cstr/replace (str target-from) ":query/" ""))))))

;;   :action/uteu! (fn [{:keys [database]}]
;;                   (= (str (get database :name)) "SQLite"))

  ;;:query-drag? [:= :drag-meta/type ":query"]
  :is-sqlite? [:= :database/name "SQLite"]
  :is-raw-sql? [:= :parent-table-str ":raw"]

;;   :xtdb-drawer/click [:and
;;                       ;[:= :database/name "PostgreSQL"]
;;                       [:like [:lower :connection-id] "%xtdb%"]]

;;   :xtdb-button/click [:and
;;                       ;[:= :database/name "PostgreSQL"]
;;                       [:like [:lower :connection-id] "%xtdb%"]]

  :xtdb-drag/temporal [:and
                       ;[:= :database/name "PostgreSQL"]
                       [:like [:lower :connection-id] "%xtdb%"]]

  :xtdb-drop/temporal-ops.SYSTEM_TIME.VALID_TIME [:and [:= :drag-meta/type ":xtdb-temporal"] :canvas-drop?]

;;   :xtdb-drop/temporal-ops2.SYSTEM_TIME.VALID_TIME [:and [:= :drag-meta/type ":xtdb-temporal"] :canvas-drop?]

  :pivot-measure? [:and [:or
                         [:= :drag-meta/type ":field"]
                         [:= :drag-meta/type ":meta-fields"]]
                   [:<> :drag-meta/data-type "string"]
                   [:<> :drag-meta/data-type "rabbit-code"]
                   :is-self?]
  :sql/pivot.pivotable-dims  [:pivot-measure?]
  ;;:sql/pivot-avg.pivotable-dims  [:pivot-measure?]
  :repl/add-as.repl-add-types    [:and [:= :runner-str ":clojure"] [:not :is-self?]]
  :repl/data-drop [:and :canvas-drop? [:= :drag-meta/type ":data"] [:= :drag-meta/runner ":clojure"]]

  ;;:sql2/true [:= 1 1]

  :sql/remove-field       [:and [:= :drag-meta/type ":field"] :is-self? :target-has-field? [:not :is-raw-sql?]]
  :sql/split-date         [:and [:= :drag-meta/type ":field"] :is-self? :drag-field/looks-like-date? [:not :is-raw-sql?]]
  :sql/order-by.asc.desc  [:and [:= :drag-meta/type ":field"] :is-self? :target-has-field? [:not :is-raw-sql?]]
  :sql/new-select.all.count  [:and
                              [:or
                               [:= :drag-meta/type ":query"]
                               [:= :drag-meta/type ":meta-tables"]]
                              :canvas-drop?]
  :dimension-drop?    [:and [:or
                             ;[:= :drag-meta/type ":meta-tables"]
                             [:= :drag-meta/type ":field"]
                             [:= :drag-meta/type ":meta-fields"]]
                       ;[:like :drag-meta/source-table ":query/%"]
                  ;;      [:or
                  ;;       [:= :drag-meta/data-type "string"]
                  ;;       [:= :drag-meta/data-type "string"]
                  ;;       [:like [:lower :drag-meta/target] "%year%"]
                  ;;       [:like [:lower :drag-meta/target] "%month%"]]
                       :canvas-drop?]
  :dimension-filter?     [:and [:<> :drag-meta/type ":meta-fields"] [:dimension-drop?]]
  :sql/new-group-by      [:and [:dimension-drop?]
                          [:or  [:= :drag-meta/type ":field"]
                           [:= :drag-meta/type ":meta-fields"]]]
  :filter/new-drop-down  [:dimension-filter?]
  :filter/new-multi-drop-down  [:dimension-filter?]
  :filter/click-table    [:dimension-filter?]
  :sql/count-distinct    [:and [:dimension-drop?]
                          [:or  [:= :drag-meta/type ":field"]
                           [:= :drag-meta/type ":meta-fields"]]]
  :sql/new-agg.sql-agg-types   [:and [:or
                                      ;[:= :drag-meta/type ":meta-tables"]
                                      [:= :drag-meta/type ":field"]
                                      [:= :drag-meta/type ":meta-fields"]]
                                        ;[:like :drag-meta/source-table ":query/%"]
                                [:<> :drag-meta/data-type "string"]
                                [:<> :drag-meta/data-type "rabbit-code"]
                                :canvas-drop?]
;;   :sql/new-agg.sum.avg.min.max.count   [:and [:= :drag-meta/type ":field"]
;;                                         [:like :drag-meta/source-table ":query/%"]
;;                                         [:<> :drag-meta/data-type "string"]
;;                                         :canvas-drop?]
  :sql/add-agg.sql-agg-types   [:and [:or
                                      [:= :drag-meta/type ":meta-fields"]
                                      [:= :drag-meta/type ":field"]]
                                      ;[:like :drag-meta/source-table ":query/%"]
                                      ;[:<> :drag-meta/data-type "string"]
                                ;[:not :drag-field/dimension?]
                                [:or [:in :drag-field/data-type ["float" "integer" "decimal"]]]
                                :drag-from-same-connection?
                                :is-query?
                                :target-is-group-by?
                                ;[:not :is-view?]
                                ;:parent-has-field?
                                [:not :target-has-field?]
                                [:not :is-self?]]
  :add-compat-dim?  [:and
                     :drag-field/dimension?
                     ;[:not [:or [:in :drag-field/data-type ["float" "integer" "decimal"]]]]
                     :is-query?
                     :drag-from-same-connection?
                     :parent-has-field?
                     [:not :target-has-field?]
                     [:not :is-self?]]

  :sql/add-count-distinct [:and
                           :add-compat-dim?
                           :target-is-group-by?]

  :sql/add-group-by [:add-compat-dim?]

  :vega/facet.column.row.2cols.3cols.4cols [:and
                                            :drag-field/dimension?
                                            :grandparent-has-field?
                          ;[:= :generated? true]
                                            :drag-field/facet-cardinality?
                                            :is-vega-lite?
                                            :drag-from-same-connection?
                          ;:parent-has-field?
                          ;[:not :is-self?]
                                            ]

  :pivot/add-as.column.row [:and
                            :drag-field/dimension?
                            :drag-field/pivot-cardinality?
                            ;[:or [:in :drag-field/data-type ["float" "integer" "decimal"]]]
                            [:= :runner-str ":pivot"]
                            [:<> :drag-meta/pivot? true]
                            :drag-from-same-connection?
                            :parent-has-field?
                            [:not :is-self?]]
  :pivot/add-agg.sum.avg.min.max [:and
                                  :drag-field/measure?
                                  ;:drag-field/pivot-cardinality?
                                 ;[:or [:in :drag-field/data-type ["float" "integer" "decimal"]]]
                                  [:= :runner-str ":pivot"]
                                  [:<> :drag-meta/pivot? true]
                                  :drag-from-same-connection?
                                  :parent-has-field?
                                  [:not :is-self?]]
  :pivot/new-pivot-table [:and :dimension-drop? :drag-field/pivot-cardinality?]
  :pivot/remove-field [:and
                       [:= :runner-str ":pivot"]
                       ;[:= :drag-meta/agg? true]
                       [:= :drag-meta/pivot? true]
                       :is-self?]
;;   :pivot/remove-agg [:and
;;                      [:= :runner-str ":pivot"]
;;                      [:= :drag-meta/pivot? true]
;;                      :is-self?]
  :pivot/swap-axes? [:and
                     [:= :runner-str ":pivot"]
                     [:= :drag-meta/pivot? true]
                     :is-self?]
  :param/new-param-view [:and [:or
                               [:= :drag-meta/type ":viewer-pull"]
                               [:= :drag-meta/type ":param"]]
                         :canvas-drop?]

  :param/new-param-data-pull [:and [:or
                                    [:= :drag-meta/type ":viewer-pull"]
                                    [:= :drag-meta/type ":param"]]
                              [:= :drag-param/type "rabbit-code"]
                              :canvas-drop?]

  :param/where.=.<>.>.< [:and
                         ;[:not [:= :drag-meta/param-type "vector"]]
                         [:or
                          [:= :drag-meta/type ":param"]
                          [:= :drag-meta/type ":where"]]
                         [:or :parent-has-field? :target-has-field?]
                         ;[:not :is-self?]
                         :is-query?]

  :formatting/highlight-rows.<.>.<=.>=.<>.= [:and
                                             ;[:not [:= :drag-meta/param-type "vector"]]
                                             [:or
                                              [:= :drag-meta/type ":param"]
                                              [:= :drag-meta/type ":where"]]
                                             ;[:or :parent-has-field? :target-has-field?]
                                             :target-has-field?
                                             :is-self?
                                             :is-query?]

  :formatting/column-heatmap [:and [:= :drag-meta/type ":field"] :is-self? :target-has-field? [:not :is-raw-sql?]]

  :param/where-in [:and
                   [:= :drag-meta/param-type "vector"]
                   :is-query?
                   [:or :parent-has-field? :target-has-field?]]
  :param/where-NOT-in [:and
                       [:= :drag-meta/param-type "vector"]
                       :is-query?
                       [:or :parent-has-field? :target-has-field?]]
  :cell-drop?        [:and :cell-drag? :canvas-drop?]
  :cell/new-view     [:cell-drop?] ;; cell-drop? = (>= (get drag-meta :row-num) 0)
  :cell/data-pull    [:or
                      [:= :drag-param/type "rabbit-code"]
                      [:and :cell-drop? [:= :drag-meta/data-type "rabbit-code"]]]
  :cell/filter-where.all.count [:cell-drop?]



  :view/query-actions.promote.delete [:and :is-query? [:= :drag-meta/type ":query"] :is-self?]
  :view/query-actions.move-to.copy-to [:and :is-query? [:= :drag-meta/type ":query"] [:not :is-self?]]

  :view/generic-clover-drop [:and :canvas-drop? [:= :drag-meta/type ":draggable-clover"]]
  :view/viz-reco-drop [:and :canvas-drop? [:= :drag-meta/type ":viz-reco"]]
  :view/tab-grid      [:and :canvas-drop? [:= :drag-meta/type ":tab-grid"]]
  ;:view/editor        [:and :canvas-drop? [:= :drag-meta/type ":editor"]]
  :view/duplicate     [:and [:= :drag-meta/type ":view"] :canvas-drop?]

;;   :action/everyone [:and [:= 122 122] :drag-field/dimension?]
;;   :action/everyone2 [:and [:= 1222 1222] :is-query?]

;;   :grid-buttonz/everyone2 [:and [:= 1 1] :is-query?]
;;   :grid-buttonz/everyone22 [:and [:= 12 12] :is-query?]
;;   :grid-buttonz2/everyone44 [:and [:= 2 2] :is-query?]

  :fresh-drop?          [:and :is-canvas-call? :no-drag?]
  :fresh/fresh-clover   [:fresh-drop?]
  :fresh/fresh-repl     [:fresh-drop?]
  :fresh/fresh-api-call [:fresh-drop?]
  :fresh/fresh-shell    [:fresh-drop?]
  :fresh/fresh-raw-sql  [:fresh-drop?]
  ;:fresh/fresh-ask-calliope  [:fresh-drop?]

  ;:action/drop-down [:and :drag-field/dimension? :drag-field/medium-cardinality?]
  ;:action/fresh-clover2 [:fresh?]
  ;:action/do-param-thing! [:<> :drag-param/field nil]
  }

;;  :fields ;; runs on all visible dataset fields. these will be accessable during a drag event via :drag-field-* - RUN LEVEL
;;  {:low-cardinality?    [:<= :field/distinct-values 20] ;; cardinality as it relates to data viz drawing dims, not generally.
;;   :medium-cardinality? [:<= :field/distinct-values 59]
;;   :high-cardinality?   [:> :field/distinct-values 60]
;;   :dimension?       [:or
;;                         [:= :field/data-type "string"]
;;                         [:= :field/data-type "date"]]
;;   :dragging?           [:and :is-dragging? [:= 22 22]]
;;   }



 :categories ;; defaults like color and location?
 {:sql {:label "SQL Actions" :locations [:drop] :color "#a1d76a"} ;; label color overrides cat color
  :cell  {:label "Cell Actions" :locations [:drop]}
  :action {:label "Random Actions" :locations [:drop]}
  :query {:label "Query Actions" :locations [:drop]}
  ;;:sql {:label "SQL Ops" :locations [:drop]}
  :filter {:label "SQL UI Filters" :locations [:drop]}
  :fresh {:label "Add Blocks" :locations [:drop]}
  :grid-buttonz {:label "Random Actions" :locations [:view]}
  :grid-buttonz2 {:label "Random Actions" :locations [:grid :view]}
  :xtdb-drag {:label "XTDB Random Actions" :locations [:grid-drag]}
  :xtdb-drop {:label "XTDB Actions" :locations [:drop]}
  :xtdb-button {:label "BUTTON"  :locations [:grid :view]} ;; :view-drag
  :xtdb-drawer  {:label "XRDB DRASRWYER"  :locations [:grid-drawer]}
  :view {:label "View Actions" :locations [:drop]}
  :pivot {:label "UI Pivot Table" :locations [:drop]}
  }

 :action-labels ;; for rendering the action buttons / drop targets in the UI
 {:filter {:new-drop-down {:color "#f5f5f5" :label ["Single Select" "Dropdown"]}
           :new-multi-drop-down {:label ["Multi Select" "Dropdown"]}
           :click-table {:color "#f5f5f5" :label ["Multi Select" "Table Filter"]}}
;;   :query {:actions.promote.delete {:label ["Query Actions" "(self)"]}}
  :view {:query-actions.promote.delete {:label ["Query Actions" "(self)"]}
         :viz-reco-drop {:color "#FDDBBB" :label ["Viz Suggestion" "Drop"]}
         :tab-grid {:color "#FDDBBB" :label ["Tab Grid" "Drop"]}
         :duplicate {:color "#FDDBBB" :label ["Duplicate" "View"]}}
  :pivot {:new-pivot-table {:label ["Crosstab" "Start a Pivot Table"]}}
  :sql {;:new-select.all.count  {}
        ;:new-agg.sum  {:color "#dcedc1" :label ["SQL Aggregate" "SUM"]}
        :split-date       {:label ["Split Date" "(year, month, day)"]}
        :new-select.count  {:color "#a1d76a"
                            :label ["SQL Count" "COUNT(1)"]}
        :new-select.all  {:color "#a1d76a"
                          :label ["SQL Select All" "SELECT * ..."]}
        :count-distinct  {:color "#a1d76a"
                          :label ["Count Distinct" "(of this field)"]}
        :new-group-by  {:color "#a1d76a"
                        :label ["Create Group By" "(plus rowcount)"]}
        :add-group-by  {:color "#a1d76a"
                        :label ["Add to Group By" ""]}
        :order-by.asc.desc {:label ["Order By" ""]}
        ;;:new-agg.sum.avg.min.max.count  {:color "#ffd3b6" :label ["SQL Aggregate" :*arg]}
        :new-agg.sql-agg-types  {:color "#ffd3b6" :label ["SQL Aggregate" :*arg]}
        :add-agg.sql-agg-types  {:color "#ffd3b6" :label ["Add SQL Agg" :*arg]}
        ;:new-agg.min  {:color "#dddddd" :label ["SQL Aggregate" "MINNY"]} ;; if overriding a dynamic label, put it AFTER the dynamic def
} ;; drop only, so not needed
  :fresh {:fresh-clover {:label ["Clover Block (View)" "(hiccup, re-com, viz)"] :icon "images/clover2.svg"} ;; "images/rabbit-console.png"} "🍀"
          :fresh-repl {:label ["REPL Block" "(clojure)"] :icon "images/clojure-alt.svg"}
          :fresh-raw-sql {:label ["SQL Block" "(raw string SQL)"] :icon "ri-database-2-line"}
          :fresh-ask-calliope {:label ["Ask Calliope" "(Rabbit Worker)"]}
          :fresh-shell {:label ["Shell Block" "(bash, etc)"] :icon "ri-terminal-line"}
          :fresh-api-call {:label ["New API Call" "(GET, POST, etc)"] :icon "zmdi-http"}}
  :grid-buttonz {:everyone2 {:icon "ri-government-line" :tooltip "some tsufsdf ytolfsdfs2"}
                 :everyone22 {:icon "ri-community-line" :tooltip "some tsufsdf ytolfsdfs22222"}}
  :grid-buttonz2 {:everyone44 {:icon "ri-home-heart-line" :tooltip "somefsdfsdfsdf tsufsdf ytolfsdfs22222"}}
  :xtdb-button {:click {:icon "zmdi-pizza" :tooltip "button click test!"}}
  :xtdb-drag {:temporal {:icon "ri-calendar-schedule-line" :tooltip "XTDB Bi-Temporal Actions"}}
  :xtdb-drop {:temporal-ops.SYSTEM_TIME.VALID_TIME {;:color "#ffffff"
                                                    :tooltip ["Add a connected scrubber slider for XTDB Bi-Temporal field" :*arg]
                                                    :label [["Temporal Scrubber"]
                                                            [:*arg "ri-timeline-view"]
                                                            ;;"more stuff"
                                                            ]
                                                    ;:clover [:box :child [:str "stuff! " :*arg] :style {:color "red"}]
                                                    }
              :temporal-ops2.SYSTEM_TIME.VALID_TIME {;:color "#ffffff"
                                                     :tooltip ["Add a calendar filter for XTDB Bi-Temporal field" :*arg]
                                                     :label [["Temporal Calendar"]
                                                             [:*arg "ri-calendar-2-line"]
                                                                          ;;"more stuff"
                                                             ]
                                                                  ;:clover [:box :child [:str "stuff! " :*arg] :style {:color "red"}]
                                                     }}
  :action {:param-where.=.<>.>.<  {:color "#f7f77f"
                                   :label ["Param Filter" :*arg]}
           :everyone {:color "#f7f77f"
                      :label ["Everyone" "Single Select"]}
           :everyone2 {:color "#fafafa"
                       :label ["Everyone2" "Single Select"]}
           :drop-down {:color "#f7f77f"
                       :label ["Dimension Dropdown" "Single Select"]}}}

 :actions-fns ;; has the action function as well as the labels and defs for that action
 {:vega {:facet.column.row.2cols.3cols.4cols  (fn [{:keys [source-kp source-block target-view target-kp target-block target-query
                                                           source-field target-block-kp parent-table target-block]}]
                                                (let [dir :*arg
                                                      base-query (get-in target-block [:queries parent-table])
                                                      new-select (vec (distinct (conj (get base-query :select []) source-field)))
                                                      new-group-by (vec (distinct (conj (get base-query :group-by []) source-field)))
                                                      new-query (-> base-query (assoc :select new-select) (assoc :group-by new-group-by))
                                                      new-view (if (or (= dir :row) (= dir :column))
                                                                 (if (map? (get-in target-view [1 :spec])) ;; 1-2 dims, row and col explicit
                                                                   ;; ^^ already has spec form, else layer form (assumes was generated shape-rotator code)
                                                                   (-> target-view
                                                                       (assoc-in [1 :facet  dir] {:field source-field}))
                                                                   (-> target-view
                                                                       (assoc-in [1 :spec] (get-in target-view [1 :layer 0]))
                                                                       (update 1 dissoc :layer)
                                                                       (assoc-in [1 :facet] {dir {:field source-field}})))
                                                                 (if (map? (get-in target-view [1 :spec])) ;; single dim, will wrap on column count X
                                                                   ;; ^^ already has spec form, else layer form (assumes was generated shape-rotator code)
                                                                   (-> target-view
                                                                       (assoc-in [1 :facet] {:field source-field})
                                                                       (assoc-in [1 :columns] (clojure.edn/read-string (subs (str dir) 1 2))))
                                                                   (-> target-view
                                                                       (assoc-in [1 :spec] (get-in target-view [1 :layer 0]))
                                                                       (update 1 dissoc :layer)
                                                                       (assoc-in [1 :facet] {:field source-field})
                                                                       (assoc-in [1 :columns] (clojure.edn/read-string (subs (str dir) 1 2))))))]
                                                  ;; (println "new-view: " dir " " target-kp)
                                                  {(vec (into target-block-kp [:queries parent-table])) new-query
                                                   target-kp new-view}))}
  :repl {:data-drop (fn [{:keys [drag-meta dragging-body]}]
                      (let [;drop-type :*arg ;; :data-ref :data-trigger :render-trigger
                            target-kp [:panels (keyword (str "block-c-" (rand-int 9999)))]
                            new-view (keyword (str "new-clojure-c-" (rand-int 9999)))
                            dtype (get-in dragging-body [:drag-meta :type])
                            src-table  (get-in dragging-body [:drag-meta :source-table])
                            src-table-string (-> (str src-table) (clojure.string/replace ":" "") (clojure.string/replace "query/" ""))
                            tfields (get-in dragging-body [:drag-meta :table-fields])
                            target-view (symbol (cstr/replace (str (get-in dragging-body [:drag-meta :param-field])) ":" ""))
                            target-bindings {(get-in dragging-body [:drag-meta :param-field])
                                             (get-in dragging-body [:drag-meta :param-full])
                                             (keyword (str "trigger-" (cstr/replace (str (get-in dragging-body [:drag-meta :param-field])) ":" "")))
                                             (keyword (cstr/replace (str (get-in dragging-body [:drag-meta :param-full])) ":data/" "data-hash/"))}
                            unwrapped-view (if (and (seq? target-view)
                                                    (= 'do (first target-view)))
                                             (second target-view)  ; get the first form after (hidden) 'do
                                             target-view)
                            existing-bindings (when (and (seq? unwrapped-view)
                                                         (= 'let (first unwrapped-view)))
                                                (set (map first (partition 2 (second unwrapped-view)))))
                            new-bindings (mapcat (fn [[k v]]
                                                   (let [base-sym (symbol (name k))
                                                         final-sym (if (contains? existing-bindings base-sym)
                                                                     (symbol (str (name k) "-" (rand-int 99)))
                                                                     base-sym)]
                                                     [final-sym v]))
                                                 target-bindings)

                            new-body (let [has-let? (and (seq? unwrapped-view)
                                                         (= 'let (first unwrapped-view)))]
                                       (if has-let?
                                         (let [[let-sym bindings & body] unwrapped-view
                                               new-bindings (vec (concat bindings new-bindings))]
                                           (concat [let-sym new-bindings] body))
                                         (list 'let
                                               (vec new-bindings)
                                               unwrapped-view)))]
                        {:w 7 :h 4
                         :selected-view new-view
                         :selected-mode {:* :text}
                         :clojure  {new-view new-body}}))
         :add-as.repl-add-types
         (fn [{:keys [drag-meta dragging-body target-view target-kp]}]
           (let [drop-type :*arg ;; :data-ref :data-trigger :render-trigger
                 dtype (get-in dragging-body [:drag-meta :type])
                 src-table  (get-in dragging-body [:drag-meta :source-table])
                 src-table-string (-> (str src-table) (clojure.string/replace ":" "") (clojure.string/replace "query/" ""))
                 tfields (get-in dragging-body [:drag-meta :table-fields])
                 target-bindings (cond
                                   (and (= dtype :query) (= (count tfields) 1)) ;; assume single value like a row count (FE filled)
                                   {;;(keyword (str src-table-string "-val"))
                                    (first tfields)
                                    (keyword (clojure.string/replace (str src-table-string "/" (first tfields) ".0") ":" ""))}

                                   (and (= dtype :query) (> (count tfields) 1)) ;; assume regular table (BE filled / injected)
                                   {(keyword (str src-table-string "-vec"))
                                    (keyword (clojure.string/replace (str "data/" src-table-string) ":" ""))}

                                   (or (= dtype :param) (= dtype :data) (= dtype :where)) ;; param
                                   {(get-in dragging-body [:drag-meta :param-field])
                                    (get-in dragging-body [:drag-meta :param-full])}

                                   (= dtype :field) ;; field (will be BE filled)
                                   {(keyword (clojure.string/replace (str "all-" (get-in dragging-body [:drag-meta :target])) ":" ""))
                                    (cond (= drop-type :data-ref+sum)
                                          (list 'apply '+ (list 'mapv
                                                                (get-in dragging-body [:drag-meta :target])
                                                                (keyword (clojure.string/replace (str "data/" src-table-string) ":" ""))))
                                          :else (list 'mapv
                                                      (get-in dragging-body [:drag-meta :target])
                                                      (keyword (clojure.string/replace (str "data/" src-table-string) ":" ""))))}

                                   (= dtype :view) ;; field (will be BE filled)
                                   {(keyword (clojure.string/replace (str "render-trigger-" (get-in dragging-body [:drag-meta :target])) ":" ""))
                                    (keyword (clojure.string/replace (str "render-hash/" src-table-string) ":" ""))}

                                                      ;;     (= dtype :data) ;; field (will be BE filled)
                                                      ;;     {(get-in dragging-body [:drag-meta :param-field])
                                                      ;;      (list 'mapv
                                                      ;;            (get-in dragging-body [:drag-meta :target])
                                                      ;;            (keyword (clojure.string/replace (str "data/" src-table-string) ":" "")))}

                                   :else {:something-else? [dtype src-table]})
                 target-bindings (assoc target-bindings (keyword (str "trigger-" src-table-string))  ;; add data-hash binding just in case to force reaction from server
                                        (keyword (clojure.string/replace (str "data-hash/" src-table-string) ":" "")))
                 unwrapped-view (if (and (seq? target-view)
                                         (= 'do (first target-view)))
                                  (second target-view)  ; get the first form after (hidden) 'do
                                  target-view)
                 existing-bindings (when (and (seq? unwrapped-view)
                                              (= 'let (first unwrapped-view)))
                                     (set (map first (partition 2 (second unwrapped-view)))))
                 new-bindings (mapcat (fn [[k v]]
                                        (let [base-sym (symbol (name k))
                                              final-sym (if (contains? existing-bindings base-sym)
                                                          (symbol (str (name k) "-" (rand-int 99)))
                                                          base-sym)]
                                          [final-sym v]))
                                      target-bindings)

                 new-body (let [has-let? (and (seq? unwrapped-view)
                                              (= 'let (first unwrapped-view)))]
                            (if has-let?
                              (let [[let-sym bindings & body] unwrapped-view
                                    new-bindings (vec (concat bindings new-bindings))]
                                (concat [let-sym new-bindings] body))
                              (list 'let
                                    (vec new-bindings)
                                    unwrapped-view)))]
             {target-kp new-body}))}
  :view        {:query-actions.promote.delete
                (fn [{:keys [drag-meta target-kp dragging-body]}]  ;; blocks are already constructed in the drag-body
                  (let [op :*arg]
                    ;(println op target-kp)
                    (when (= op :promote)
                      {target-kp [:materialize-sql (last target-kp)]})))
                :generic-clover-drop (fn [{:keys [drag-meta dragging-body]}]  ;; blocks are already constructed in the drag-body
                                       (dissoc dragging-body :drag-meta :conditionals))
                :viz-reco-drop (fn [{:keys [drag-meta dragging-body]}]
                                 (dissoc dragging-body :drag-meta :conditionals))
                :tab-grid (fn [{:keys [drag-meta dragging-body]}]
                            (dissoc dragging-body :drag-meta :conditionals))} ;; blocks are already constructed in the drag-body
  :xtdb-button {:click      (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field]}]
                              (let [existing-select   (vec (shuffle (get target-query :select [])))
                                    target-deep-keypath-sel (conj target-kp :select)]
                                {target-deep-keypath-sel existing-select}))}
  :xtdb-drawer {:click      (fn [{:keys []}]
                              {:body [:box :size "auto"
                                      ;:width :panel-width+50-px
                                      :height :panel-height+50-px
                                      :align :center :justify :center
                                      :style {:color "red" :font-size "36px"
                                              ;:border "1px solid green"
                                              }
                                      :child [:speak (str "hold yer horses" (rand-int 12))]]
                               :runner :views
                               :title "bad moon risin', rage an' ruin!"
                               :action-type :clover-drawer
                               :target :query
                               :block-id :wow333
                               :view-id :wow
                               :size 5
                               :position :bottom
                               :style-override {}
                               :icon "ri-pie-chart-2-fill"
                               :tooltip "Bad moon is risin'"})}
  :xtdb-drag   {:temporal  (fn [{:keys [source-kp source-block]}]
                             ;; we are creating the drag-meta map for a drop action...
                             (let [{:keys [selected-view connection-id]} source-block]
                               {:type :xtdb-temporal
                                :connection-id connection-id
                                :source-query selected-view
                                :source-table (keyword (str "query/" (clojure.string/replace (str selected-view) ":" "")))}))}
  :xtdb-drop   {:temporal-ops.SYSTEM_TIME.VALID_TIME  (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field drag-meta]}]
                                                        (let [existing-where (get target-query :where [])
                                                              ww [:*when (get drag-meta :param-full)
                                                                  [:*arg (get drag-meta :param-full) (get drag-meta :param-field)]]
                                                              new-where (if (empty? existing-where) ww [:and existing-where ww])
                                                              target-deep-keypath (conj target-kp :where)]
                                                          {target-deep-keypath new-where}))}
  :param  {:new-param-view (fn [{:keys [drag-meta]}]
                             (let [{:keys [param-field param-full param-type]} drag-meta
                                   view (if (not (vector? param-full))
                                          [:box :child [:str param-full]
                                           :style {:font-size "20px"
                                                   :color :theme/editor-outer-rim-color}
                                           :size "auto" :align :center :justify :center]
                                          param-full)]
                               {:h 2 :w 5
                                :selected-view :param-view
                                :views {:param-view view}}))
           :where.=.<>.>.<  (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field drag-meta]}]
                              (let [existing-where (get target-query :where [])
                                    ww [:*when (get drag-meta :param-full)
                                        [:*arg (get drag-meta :param-full) (get drag-meta :param-field)]]
                                    new-where (if (empty? existing-where) ww [:and existing-where ww])
                                    target-deep-keypath (conj target-kp :where)]
                                {target-deep-keypath new-where}))}
  :pivot {:new-pivot-table (fn [{:keys [drag-meta source-query-body source-kp]}]
                             (let [{:keys [connection-id source-panel-key source-query source-table param-field row-num target table-fields]} drag-meta
                                   new-param    (keyword (clojure.string/replace (str :*this-block* "/" target) ":" ""))
                                   table-alias  (keyword (str "ddr" (rand-int 99)))
                                   parent-where (get source-query-body :where)
                                   parent-table (first (flatten (get source-query-body :from)))
                                   exists?      (not (nil? parent-where))
                                   cla           [:*when new-param [:= new-param target]]
                                   new-where     (if exists? [:and parent-where cla] cla)]
                               {:h 5 :w 6
                                :selected-view :pivot1
                                :connection-id connection-id
                                :pivot {:pivot1 {:rowset-keypath [source-query]
                                                 :rowset-query [source-table]
                                                 :row-keys [target]
                                                 :column-keys ["all"]
                                                          ;:agg-specs [[:rowcnt :count 1 :*]]
                                                 :agg-specs []}}}))

          :add-agg.sum.avg.min.max (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field]}]
                                    (let [agg :*arg
                                          agg-vec [source-field agg 0 source-field]
                                          agg-specs (vec (distinct (conj (vec (remove (fn [x] (= x agg-vec)) (get target-query :agg-specs [])))
                                                                        agg-vec)))
                                          target-deep-keypath-ob (conj target-kp :agg-specs)]
                                      {target-deep-keypath-ob agg-specs}))

          :add-as.column.row (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field]}]
                               (let [direction :*arg
                                     kkey (if (= direction :column) :column-keys :row-keys)
                                     order-by (vec (distinct (conj (vec (remove (fn [x] (or (string? x) (= x source-field))) (get target-query kkey [])))
                                                                   source-field)))
                                     target-deep-keypath-ob (conj target-kp kkey)]
                                 {target-deep-keypath-ob order-by}))
          :swap-axes? (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field]}]
                        (let [rr (get target-query :row-keys)
                              cc (get target-query :column-keys)
                              target-query (-> target-query (assoc :row-keys cc) (assoc :column-keys rr))]
                          {target-kp target-query}))
          :remove-field (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field]}]
                          (let [rr (vec (remove (fn [x] (= x source-field)) (get target-query :row-keys)))
                                cc (vec (remove (fn [x] (= x source-field)) (get target-query :column-keys)))
                                rr  (if (empty? rr) ["all"] rr)
                                cc  (if (empty? cc) ["all"] cc)
                                aa (vec (remove (fn [x] (= (first x) source-field)) (get target-query :agg-specs)))
                                target-query (-> target-query (assoc :row-keys rr) (assoc :column-keys cc) (assoc :agg-specs aa))]
                            {target-kp target-query}))}

;;          (let [existing (get-in db [:panels panel-key :queries query-key :style-rules] {})
;;         heatmap? (true? (= clause-conform :heatmap))
;;         rname    (keyword (str (if heatmap? "heatmap-" "highlight-") (rand-int 12345)))]
;;     (assoc-in db
;;               [:panels panel-key :queries query-key :style-rules]
;;               (merge existing
;;                      {(if (= clause-conform :heatmap) [(get-in drop-data [:drag-body :param-field]) rname] [:* rname])
;;                       {:logic (if (= clause-conform :heatmap)
;;                                 true
;;                                 [(condp = clause-conform :highlight= := :highlight> :> :highlight< :<)
;;                                  (get-in drop-data [:drag-body :param-field]) (get-in drop-data [:drag-body :param-full])])
;;                        :style (merge {:background-color (if (= clause-conform :heatmap)
;;                                                           [:heatmap] ;; :PuOr :11 :asc
;;                                                           "#008b8b66")
;;                                       :border           "1px solid #00000000"}
;;                                      (if (= clause-conform :heatmap) {:color "#000000"} {}))}})))

  :formatting {:highlight-rows.<.>.<=.>=.<>.=
               (fn [{:keys [source-kp drag-meta source-block dragging-body source-query target-kp target-block target-query source-field]}]
                 (let [clause-conform :*arg
                       {:keys [param-full param-field]} drag-meta
                       heatmap? (true? (= clause-conform :heatmap))
                       rname    (keyword (str (if heatmap? "heatmap-" "highlight-") (rand-int 12345)))
                       existing (get target-query :style-rules {})
                       existing (merge existing
                                       {(if (= clause-conform :heatmap) [source-field rname] [:* rname])
                                        {:logic (if (= clause-conform :heatmap)
                                                  true
                                                  [clause-conform ;(condp = clause-conform :highlight= := :highlight> :> :highlight< :<)
                                                   param-field param-full])
                                         :style (merge {:background-color (if (= clause-conform :heatmap)
                                                                            [:heatmap nil nil :asc] ;; :PuOr :11 :asc
                                                                            :theme/pop-1)
                                                        :border           "1px solid #00000000"}
                                                       (if (= clause-conform :heatmap) {:color "#000000"} {}))}})
                       target-query (assoc target-query :style-rules existing)]
                   {target-kp target-query}))

               :column-heatmap (fn [{:keys [source-kp source-block dragging-body source-query target-kp target-block target-query source-field]}]
                                 (let [clause-conform :heatmap
                                       heatmap? (true? (= clause-conform :heatmap))
                                       rname    (keyword (str (if heatmap? "heatmap-" "highlight-") (rand-int 12345)))
                                       existing (get target-query :style-rules {})
                                       existing (merge existing
                                                       {(if (= clause-conform :heatmap) [source-field rname] [:* rname])
                                                        {:logic (if (= clause-conform :heatmap)
                                                                  true
                                                                  [(condp = clause-conform :highlight= := :highlight> :> :highlight< :<)
                                                                   source-field (get dragging-body :param-full)])
                                                         :style (merge {:background-color (if (= clause-conform :heatmap)
                                                                                            [:heatmap nil nil :asc] ;; :PuOr :11 :asc
                                                                                            "#008b8b66")
                                                                        :border           "1px solid #00000000"}
                                                                       (if (= clause-conform :heatmap) {:color "#000000"} {}))}})
                                       target-query (assoc target-query :style-rules existing)]
                                   {target-kp target-query}))}

  :sql    {:split-date (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field target-db-type]}]
                         (let [existing-group-by (get target-query :group-by [])
                               date-in-group-by? (some (fn [x] (= source-field x)) existing-group-by)
                               target-db-type (clojure.string/lower-case target-db-type)
                               new-fields (cond
                                            (= target-db-type "sqlite")
                                            [[[:strftime "%Y" source-field] (-> (str source-field "_year") (clojure.string/replace ":" "") keyword)]
                                             [[:strftime "%m" source-field] (-> (str source-field "_month") (clojure.string/replace ":" "") keyword)]
                                             [[:strftime "%d" source-field] (-> (str source-field "_day") (clojure.string/replace ":" "") keyword)]]

                                            (= target-db-type "clickhouse")
                                            [[[:toYear source-field] (-> (str source-field "_year") (clojure.string/replace ":" "") keyword)]
                                             [[:toMonth source-field] (-> (str source-field "_month") (clojure.string/replace ":" "") keyword)]
                                             [[:toDay source-field] (-> (str source-field "_day") (clojure.string/replace ":" "") keyword)]]

                                            :else  ;; postgres, h2, duckdb, etc... the most "ANSI" version..
                                            [[[:extract "year" source-field] (-> (str source-field "_year") (clojure.string/replace ":" "") keyword)]
                                             [[:extract "month" source-field] (-> (str source-field "_month") (clojure.string/replace ":" "") keyword)]
                                             [[:extract "day" source-field] (-> (str source-field "_day") (clojure.string/replace ":" "") keyword)]])
                               existing-select   (get target-query :select [])
                               new-select        (vec (distinct (into existing-select new-fields)))
                               new-group-by      (if date-in-group-by?
                                                   (vec (distinct (into existing-group-by new-fields)))
                                                   existing-group-by)
                               target-deep-keypath-gp (conj target-kp :group-by)
                               target-deep-keypath-sel (conj target-kp :select)]
                           {target-kp (if (empty? new-group-by)
                                        (-> target-query (assoc :select new-select))
                                        (-> target-query
                                            (assoc :select new-select)
                                            (assoc :group-by new-group-by)))}))

           :pivot.pivotable-dims (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field]}]
                                   (let [pivot-field :*arg
                                         agg-field source-field
                                         existing-q target-query
                                         remove-key (fn [coll key]
                                                      (vec (mapcat (fn [item]
                                                                     (cond (keyword? item) (when (not= key item) [item])
                                                                           (vector? item)  (let [last-in-vector (last item)]
                                                                                             (if (and (keyword? last-in-vector) (= key last-in-vector)) [] [item]))
                                                                           :else           [item]))
                                                                   coll)))
                                         aggy (if (= agg-field :rowcnt) :count [:sum agg-field])
                                         pivot-by-map {pivot-field [aggy
                                                                    {:select-distinct [pivot-field]
                                                                     :from            [[existing-q (keyword (str "pivotq"))]]}]}
                                         new-query    (-> existing-q
                                                          (assoc :pivot-by pivot-by-map)
                                                          (assoc :select (remove-key (get existing-q :select) pivot-field))
                                                          (assoc :group-by (remove-key (get existing-q :group-by) pivot-field)))

                                         new-query    (if (empty? (get new-query :group-by)) ;; if no group by, remove it - single dim, measure pivots
                                                        (dissoc new-query :group-by)
                                                        new-query)]
                                     {target-kp new-query}))

           :add-group-by (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field]}]
                           (let [existing-group-by (get target-query :group-by [])
                                 existing-select   (get target-query :select [])
                                 new-select        (vec (distinct (conj existing-select source-field))) ;; in case added twice
                                 new-group-by      (vec (distinct (conj existing-group-by source-field))) ;; in case added twice
                                 target-deep-keypath-gp (conj target-kp :group-by)
                                 target-deep-keypath-sel (conj target-kp :select)]
                                        ;; ^^ it would have been shorter to mutate the whole query and send whole,
                                        ;;    but demoing here how we can do 2 deep assoc-in writes instead
                             {target-deep-keypath-gp new-group-by
                              target-deep-keypath-sel new-select}))

           :order-by.asc.desc (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field]}]
                                (let [direction :*arg
                                      order-by (conj (vec (remove (fn [x] (= (first x) source-field)) (get target-query :order-by [])))
                                                     [source-field direction])
                                      target-deep-keypath-ob (conj target-kp :order-by)]
                                  {target-deep-keypath-ob order-by}))

           :remove-field (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field]}]
                           (let [select (vec (remove (fn [x] (or (= x source-field) (and (vector? x) (= (last x) source-field))))
                                                     (get target-query :select [])))
                                 order-by (vec (remove (fn [x] (or (= x source-field) (and (vector? x) (= (first x) source-field))))
                                                       (get target-query :order-by [])))
                                 target-query (-> target-query (assoc :select select) (assoc :order-by order-by))
                                 target-query (if (empty? order-by) (dissoc target-query :order-by) target-query)
                                 ;target-deep-keypath-sel (conj target-kp :select)
                                 ;target-deep-keypath-ob (conj target-kp :order-by)
                                 ]
                             {target-kp target-query}))

           :new-select.all.count (fn [{:keys [drag-meta]}]
                                   (let [{:keys [connection-id type source-table table-fields]} drag-meta
                                         table-fields (vec (distinct table-fields))
                                         op :*arg
                                         sub-query? (= type :query)
                                         all? (= op :all)
                                         qname (keyword
                                                (str (if all? "all-" "cnt-")
                                                     (-> (str source-table)
                                                         (clojure.string/replace ":query/" "")
                                                         (clojure.string/replace ":" "")
                                                         (clojure.string/replace "_" "-"))))
                                         source-table (if sub-query?
                                                        (keyword (str "query/" (clojure.string/replace (str source-table) ":" "")))
                                                        source-table)
                                         table-alias (keyword (str "ssb99"))
                                         query {:select (if all?
                                                          table-fields
                                                          [[[:count 1] :rowcnt]])
                                                :from [[source-table table-alias]]}]
                                      ;; (pp [:drag-meta ?connection-id source-query sopurce-table table-fields])
                                     {:h (if all? 6 4)
                                      :w (if all? (max 7 (min 25 (Math/ceil (* (count table-fields) 1.2)))) 6)
                                      :connection-id connection-id
                                      :selected-view qname
                                      :queries {qname query}}))

           :new-group-by (fn [{:keys [drag-meta]}]
                           (let [{:keys [connection-id source-query source-table target table-fields]} drag-meta
                                 qname (keyword (str "grouped-"
                                                     (-> (str source-table)
                                                         (clojure.string/replace ":query/" "")
                                                         (clojure.string/replace ":" "")
                                                         (clojure.string/replace "_" "-"))))
                                 table-alias (keyword (str "ssb" (rand-int 99)))
                                 query {:select [target [[:count 1] :rowcnt]]
                                        :from [[source-table table-alias]]
                                        :order-by [[:rowcnt :desc]]
                                        :group-by [target]}]
                             {:h 4 :w 6
                              :connection-id connection-id
                              :selected-view qname
                              :queries {qname query}}))

           :new-agg.sum.avg.min.max.count (fn [{:keys [drag-meta]}]
                                            (let [{:keys [connection-id source-query source-table target table-fields]} drag-meta
                                                  qname (keyword (str "agg-"
                                                                      (-> (str source-table)
                                                                          (clojure.string/replace ":query/" "")
                                                                          (clojure.string/replace ":" "")
                                                                          (clojure.string/replace "_" "-"))))
                                                  table-alias (keyword (str "ssb" (rand-int 99)))
                                                  query {:select [[[:*arg target] target]]
                                                         :from [[source-table table-alias]]}]
                                              {:h 4 :w 6
                                               :connection-id connection-id
                                               :selected-view qname
                                               :queries {qname query}}))

           :add-agg.sql-agg-types (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field]}]
                                    (let [agg-type :*arg
                                          new-select (conj (vec (get target-query :select))
                                                           [[agg-type source-field]
                                                            (keyword (cstr/replace (str source-field "_" agg-type) ":" ""))])
                                          target-deep-keypath (conj target-kp :select)]
                                      ;(println "add-agg " new-select)
                                      {target-deep-keypath new-select}))

           :add-count-distinct  (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field]}]
                                  (let [agg-type :cntd
                                        new-select (conj (vec (get target-query :select))
                                                         [[:count [:distinct source-field]]
                                                          (keyword (cstr/replace (str source-field "_" agg-type) ":" ""))])
                                        target-deep-keypath (conj target-kp :select)]
                                    {target-deep-keypath new-select}))

           :count-distinct (fn [{:keys [drag-meta]}]
                             (let [{:keys [connection-id source-query source-table target table-fields]} drag-meta
                                   qname (keyword (str "countd-"
                                                       (-> (str source-table)
                                                           (clojure.string/replace ":query/" "")
                                                           (clojure.string/replace ":" "")
                                                           (clojure.string/replace "_" "-"))))
                                   table-alias (keyword (str "ssb" (rand-int 99)))
                                   query {:select [[[:count [:distinct target]] target]]
                                          :from [[source-table table-alias]]}]
                               {:h 4 :w 6
                                :connection-id connection-id
                                :selected-view qname
                                :queries {qname query}}))}
  :filter {:new-drop-down (fn [{:keys [drag-meta source-query-body source-kp]}]
                            (let [{:keys [connection-id source-panel-key source-query param-field row-num target table-fields]} drag-meta
                                  new-param    (keyword (clojure.string/replace (str :*this-block* "/" target) ":" ""))
                                  table-alias  (keyword (str "ddr45"))
                                  parent-where (get source-query-body :where)
                                  parent-table (first (flatten (get source-query-body :from)))
                                  exists?      (not (nil? parent-where))
                                  cla           [:*when new-param [:= new-param target]]
                                  new-where     (if exists? [:and parent-where cla] cla)
                                  view-body [:dropdown {:choices :query1
                                                        :width   :panel-width+80-px
                                                        :style   {:padding-top "8px"
                                                                  :font-size   "19px"}
                                                        :ref (keyword (clojure.string/replace (str "query/" source-query) ":" ""))
                                                      ;:model   [:or! [:dash8 k] ]
                                                        :model   new-param
                                                       ;:field   [new-q-key target-field]
                                                        :field target}]]
                              {:h 2 :w 6
                               :selected-view :dropdown1
                               :connection-id connection-id
                               :drop-mutate {(vec (into source-kp [:where])) new-where}
                               :views {:dropdown1 view-body}
                               :queries {:query1 {:select   [[target :label] [target :id]]
                                                  :from     [[parent-table table-alias]]
                                                  :group-by [target]
                                                  :order-by [[target :asc]]}}}))

           :new-multi-drop-down (fn [{:keys [drag-meta source-query-body source-kp]}]
                                  (let [{:keys [connection-id source-panel-key source-query param-field row-num target table-fields]} drag-meta
                                        new-param    (keyword (clojure.string/replace (str :*this-block* "/" target) ":" ""))
                                        table-alias  (keyword (str "ddr45"))
                                        parent-where (get source-query-body :where)
                                        parent-table (first (flatten (get source-query-body :from)))
                                        exists?      (not (nil? parent-where))
                                        cla           [:*when new-param [:in target new-param]]
                                        new-where     (if exists? [:and parent-where cla] cla)
                                        view-body [:multi-dropdown {:choices :query1
                                                                    :width   :panel-width+80-px
                                                                    :style   {:padding-top "8px"
                                                                              :font-size   "19px"}
                                                                    :ref (keyword (clojure.string/replace (str "query/" source-query) ":" ""))
                                                         ;:model   [:or! [:dash8 k] ]
                                                                    :model   new-param
                                                         ;:field   [new-q-key target-field]
                                                                    :field target}]]
                                    {:h 2 :w 6
                                     :selected-view :mdropdown1
                                     :connection-id connection-id
                                     :drop-mutate {(vec (into source-kp [:where])) new-where}
                                     :views {:mdropdown1 view-body}
                                     :queries {:query1 {:select   [[target :label] [target :id]]
                                                        :from     [[parent-table table-alias]]
                                                        :group-by [target]
                                                        :order-by [[target :asc]]}}}))

           :click-table (fn [{:keys [drag-meta source-query-body source-kp]}]
                          (let [{:keys [connection-id source-panel-key source-query param-field row-num target table-fields]} drag-meta
                                ;;new-param    (keyword (clojure.string/replace (str :query1 "/" target) ":" ""))  ;; regular single param click
                                new-param    (keyword (clojure.string/replace (str :query1 "/*.clicked") ":" ""))
                                table-alias  (keyword (str "ctr" (rand-int 45)))
                                parent-where (get source-query-body :where)
                                parent-table (first (flatten (get source-query-body :from)))
                                exists?      (not (nil? parent-where))
                                ;cla          [:*when new-param [:= new-param target]] ;; regular single param click
                                cla          [:*if new-param [:*all= new-param [target]] [:= 1 1]]
                                new-where    (if exists? [:and parent-where cla] cla)]
                            {:h 6 :w 6
                             :selected-view :query1
                             :connection-id connection-id
                             :drop-mutate {(vec (into source-kp [:where])) new-where}
                             :queries {:query1 {:select   [target [[:count 1] :rowcnt]]
                                                :from     [[parent-table table-alias]]
                                                :group-by [target]
                                                :order-by [[:rowcnt :desc]]
                                                ;:order-by [[target :asc]]
                                                }}}))}
  :cell {
         :new-view (fn [{:keys [drag-meta]}]
                     (let [{:keys [connection-id source-query source-table param-field row-num target table-fields]} drag-meta
                           vname (keyword (str "cell-"
                                               (-> (str source-table)
                                                   (clojure.string/replace ":query/" "")
                                                   (clojure.string/replace ":" "")
                                                   (clojure.string/replace "_" "-"))))
                           cell-keyword (keyword (clojure.string/replace (str source-query "/" param-field "." row-num) ":" ""))]
                       {:h 2 :w 4
                        :connection-id connection-id
                        :selected-view vname
                        :views {vname [:box
                                       :size "auto" :align  :center :justify :center
                                       :style {:font-size "18px" :color :theme/editor-font-color}
                                       :child [:str cell-keyword]]}}))

         :data-pull (fn [{:keys [drag-meta]}]
                      (let [{:keys [connection-id source-query source-table param-field row-num target table-fields]} drag-meta
                            vname (keyword (str "cell-"
                                                (-> (str source-table)
                                                    (clojure.string/replace ":query/" "")
                                                    (clojure.string/replace ":" "")
                                                    (clojure.string/replace "_" "-"))))
                            cell-keyword (keyword (clojure.string/replace (str source-query "/" param-field "." row-num) ":" ""))]
                        {:h 2 :w 4
                         :connection-id connection-id
                         :selected-view vname
                         :views {vname [:data-viewer cell-keyword]}}))

         :filter-where.all.count (fn [{:keys [drag-meta parent-query-metadata]}]
                                   (let [{:keys [connection-id type param-field param-full source-table source-query table-fields]} drag-meta
                                         op :*arg
                                         all? (= op :all)
                                         table-fields (vec (keys (get parent-query-metadata :fields)))
                                         qname (keyword
                                                (str (if all? "all-" "cnt-")
                                                     (-> (str source-table)
                                                         (clojure.string/replace ":query/" "")
                                                         (clojure.string/replace ":" "")
                                                         (clojure.string/replace "_" "-"))))
                                         table-alias (keyword (str "ssb" (rand-int 99)))
                                         query {:select (if all?
                                                          table-fields
                                                          [[[:count 1] :rowcnt]])
                                                :where [:= param-field param-full]
                                                :from [[source-table table-alias]]}]
                                                                       ;; (pp [:drag-meta ?connection-id source-query sopurce-table table-fields])
                                     {:h (if all? 6 4)
                                      :w (if all? (max 32 (+ 2 (Math/ceil (* (count table-fields) 1.2)))) 6)
                                      :connection-id connection-id
                                      :selected-view qname
                                      :queries {qname query}}))}

  :fresh  {:fresh-clover (fn [{:keys [source-kp source-block source-query target-kp target-block target-query settings source-field]}]
                           {:w 7 :h 4
                            :selected-view :vv1
                            :views {:vv1 [:box
                                          :size "auto"
                                          :align :center :justify :center
                                          :style {:font-size "19px"
                                                  :color :theme/editor-outer-rim-color}
                                          :child (rand-nth (get settings :new-block-rand))]}})
           :fresh-repl (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field]}]
                         {:w 7 :h 4
                          :selected-view :new-clojure
                          :selected-mode {:* :text}
                          :clojure  {:new-clojure (quote (do (let [clojure-version (clojure-version)
                                                                   jvm-version     (System/getProperty
                                                                                    "java.version")]
                                                               (str
                                                                "🐇🥕 Sup! Internal RVBBIT nREPL. Clojure "
                                                                clojure-version
                                                                " on " jvm-version
                                                                " JVM tech" " 🥕🐇"))))}})
      ;;      :fresh-raw-sql (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field]}]
      ;;                       {:w 7 :h 4
      ;;                        :selected-view :new-raw-sql
      ;;                        :selected-mode {:* :text}
      ;;                        :raw-sql  {:new-raw-sql ["-- system-db"
      ;;                                                 "select 42 as the_answer;"
      ;;                                                 "-- to use rabbit reactive param keywords wrap them in {{}}"
      ;;                                                 ""]}})
           :fresh-raw-sql (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field]}]
                            {:w 14 :h 6
                             :selected-view :new-raw-sql
                             ;;:selected-mode {:* :text}
                             :queries {:new-raw-sql {:select [:*]
                                                     :connection-id "systemh2-db"
                                                     :from
                                                     [[[:raw
                                                        [(str "(-- systemh2-db
select * from
client_stats c1) rawsub")]]]]}}})


           :fresh-shell (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field]}]
                          {:w 7 :h 4
                           :selected-view :new-shell
                           :selected-mode {:* :text}
                           :shell  {:new-shell ["pwd ; whoami ; uname -s -m"]}})
           :fresh-api-call (fn [{:keys [source-kp source-block source-query target-kp target-block target-query source-field]}]
                             {:w 7 :h 4
                              :selected-view :new-api-call
                              :selected-mode {:* :text}
                              :api-call
                              {:new-api-call
                               {:endpoint
                                "https://owen-wilson-wow-api.onrender.com/wows/random"
                                :method :get
                                :params {:results 15}
                                :flatten? true}}})}
  :action {;;   :everyone (fn [{:keys [source-kp source-block source-view target-kp target-block target-view source-item]}]
         ;;               [:box :child "hi"])
           :fresh-clover2 (fn [{:keys [drag-block target-block]}]
                            {:w 7 :h 4
                             :selected-view :vv1
                             :views {:vv1 [:box
                                           :size "auto"
                                           :padding "10px"
                                           :align :center :justify :center
                                           :style {:font-size "22px"}
                                           :child "howdy"]}})

           ;:everyone (fn [context-map] [:context-map! context-map])
           ;:everyone2 (fn [{:keys [drag-block target-block]}] [:box :child "hi"])
           ;:drop-down (fn [{:keys [drag-block target-block]}] [:box :child "hi"])
           }}

}

